# 문제 
파티

# 시간 
58m (실패) 

# 소스코드

```python
from sys import stdin
from collections import deque
input = stdin.readline
N, M, X = map(int, input().split())

inputs = [list(map(int, input().split())) for _ in range(M)]
# 노드마다, 연결된 노드 링크드 리스트
graphs=[[] for i in range(N+1)]

for x,y,t in inputs:
    graphs[x].append((y,t))

def find(i,j,k):
    num=0; que = deque()
    que.append((j,k))
    while que:
        s,t = que.popleft()
        num += t
        if s == i:
            break 
        else:
            for ns, nt in graphs[s]:
                que.append((ns,nt))        
    return num


ans=[0]*(N+1)
for i in range(1,N+1):
    nums=[]
    for j,t in graphs[i]:
        num = find(i, j, t)
        nums.append(num)
            
    ans[i] = min(nums)

print(max(ans))

```

# 풀이
- 현재 풀이는 최소 값에서 이를 더하는 경우가 아니라서 정답이 되지 못한다. 

# 기록
- 어떻게 순회를 시켜야하는지 순서를 배정하기가 어려워 시간을 들였다. 
- 다익스트라 알고리즘을 활용할 수 있다고 해서, 최단 거리 테이블을 만들어 다시 풀이해볼 예정이다. 




